import numpy as np
from sting.utils import graph_matrices
import pandas as pd
import gamspy as gsp
import gamspy_base
from dataclasses import dataclass, field
from collections import namedtuple
from sting.system.core import System
import subprocess
import os


def calc_power_flow_in_branch(row: pd.Series):
    '''Computes active power flow, reactive power flow, and losses in a branch
    
    Args:
    ----
        row (pd.Series): It can be a row of dataframe that has the properties of the branch
        with this columns: from_bus_vmag, from_bus_vphase, to_bus_vmag, to_bus_vphase, r and l.
        Where:  from_bus_vmag and to_bus_vmag are in p.u.
                from_bus_vphase and to_bus_vphase are in radians.
                r and l are in p.u.
    
    Returns:
    -------
        p (float): active power [p.u.] injected at 'from bus'.
        plosses (float): losses [p.u.] by resistive effect.
        q (float): reactive power [p.u.] injected at 'from bus'.
        qlosses (float): losses [p.u.] by reactance.
    
    '''

    # Extract voltage and branch parameters
    v1mag = row['from_bus_vmag']
    v1phase = row['from_bus_vphase']
    v2mag = row['to_bus_vmag']
    v2phase = row['to_bus_vphase']
    r = row['r']
    l = row['l']

    # Power flow calculations
    v1 = v1mag * np.exp(v1phase * 1j)
    v2 = v2mag * np.exp(v2phase * 1j)
    i = (v1 - v2)/(r + 1j*l)
    s = v1*np.conjugate(i)
    p = s.real
    q = s.imag
    ploss = r*(np.abs(i))**2
    qloss = l*(abs(i))**2

    return p, ploss, q, qloss

def calc_power_flow_in_shunt(row: pd.Series):
    '''Computes active and reactive power going from connection bus of a shunt.
    
    Args:
    ----
        row (pd.Series): It is a row of a dataframe with the columns bus_vmag, bus_vphase,
        g, and b. Where bus_vmag is the voltage magnitude [p.u.] at the connection bus, 
        bus_vphase is the voltage phase [rad] at the connection bus, g is the conductance [p.u] of
        the shunt, and b is the susceptance [p.u.] of the shunt.

    Returns:
    -------
        p (float): active power [p.u.] going from connection bus to ground.
        q (float): reactive power [p.u.] going from connection bus to ground.

    '''

    # Extract voltage and branch parameters
    vmag = row['bus_vmag']
    vphase = row['bus_vphase']
    g = row['g']
    b = row['b']

    # Power flow calculations
    v = vmag * np.exp(vphase * 1j)
    i = v*(g + b*1j)
    s = v*np.conjugate(i)
    p = s.real
    q = s.imag 
    
    return p, q
                    
@dataclass(slots=True)
class Power_flow:
    '''Computes, validates, and prints power flow solution for a given system.'''

    system: System

    generators: pd.DataFrame  = field(init=False)
    ''' It contains the data of generators'''
    
    buses: pd.DataFrame  = field(init=False)
    '''It contains the data of buses'''

    branches: pd.DataFrame  = field(init=False)
    '''it contains branches'''
    
    shunts: pd.DataFrame  = field(init=False)
    '''It contains shunts'''

    acopf_settings: dict = field(default_factory= lambda: {'shedding_cost': 1000, 
                        'formulation_type': 'polar_form', 
                      'solver': 'IPOPT',
                      'print': 'full'})
    '''Settings applied to power flow calculations'''
    
    print_settings: dict=  field(default_factory= lambda:{'index' : True, 
                            'tablefmt': "psql",
                            'numalign': "right", 
                            'floatfmt': '.3f'})
    '''Settings applied to the tabulate package that is used to print dataframes nicely in Python shelf'''

    solver_summary: pd.DataFrame=field(default_factory=pd.DataFrame)
    '''It contains the results of the power flow solution. It is generated by Gamspy after solving the model.'''

    def __post_init__(self):
        self.check_required_solvers()
        self.build_generators_dataframe()
        self.build_buses_dataframe()
        self.build_shunts_dataframe()
        self.build_branches_dataframe()
        
    def check_required_solvers(self):
        list_of_installed_solvers = gsp.utils.getInstalledSolvers(gamspy_base.directory)

        if self.acopf_settings['solver'] not in list_of_installed_solvers:

            command = ["gamspy install solver ipopt"]

            try:
            # Execute the command
            # capture_output=True captures stdout and stderr
            # text=True decodes the output as text
                result = subprocess.run(command, shell=True,capture_output=True, text=True, check=True)

                # Print the output of the command
                print(result.stdout)

            except subprocess.CalledProcessError as e:
                print(f"Error executing command: {e}. Power Flow may not be executed.")

    
    def build_generators_dataframe(self):
        ''' Generate the dataframe generators with the layout:
                 bus_idx  p_min  p_max  q_min  q_max
        idx                                     
        inf1           1   -2.0    2.0   -5.0    5.0
        ...'''

        generator_types_list = self.system.generator_types_list  # get list of generator types
        
        idx, bus_idx, p_min, p_max, q_min, q_max  = [], [], [], [], [], [] # parameters to use in opf

        for gentype in generator_types_list: # iterate over each generator type
            gens = getattr(self.system, gentype)
            idx.extend([g.idx for g in gens])
            bus_idx.extend([g.bus_idx for g in gens])
            p_min.extend([g.p_min for g in gens])
            p_max.extend([g.p_max for g in gens])
            q_min.extend([g.q_min for g in gens])
            q_max.extend([g.q_max for g in gens])
        
        self.generators = pd.DataFrame({'idx': idx,'bus_idx': bus_idx, 'p_min': p_min, 'p_max': p_max, 'q_min': q_min, 'q_max': q_max}).set_index('idx')

    def build_buses_dataframe(self):
        '''It contains the data of buses and has the following layout:
                 v_min  v_max   p_load   q_load
        idx                              
        1        1.00    1.0  0.0  0.0'''

        idx, v_min, v_max, p_load, q_load  = [], [], [], [], []

        buses = getattr(self.system, 'bus')
        idx.extend([n.idx for n in buses])
        v_min.extend([n.v_min for n in buses])
        v_max.extend([n.v_max for n in buses])
        p_load.extend([n.p_load for n in buses])
        q_load.extend([n.q_load for n in buses])

        self.buses = pd.DataFrame({'idx': idx, 'v_min': v_min, 'v_max': v_max, 'p_load': p_load, 'q_load': q_load}).set_index('idx')
    
    def build_branches_dataframe(self):
        '''it contains branches. They may come from dissecting a line into branches and shunts.
                 from_bus  to_bus     r     l
        idx                               
        txwose1         1       2  0.01  0.05'''

        idx, from_bus, to_bus, r, l = [], [], [], [], []

        branch_types_list = self.system.branch_types_list

        # note: we assume that there is only one branch (whatever type) between two adjecent buses 
        for branchtype in branch_types_list: # iterate over each branch type
            brs = getattr(self.system, branchtype)
            idx.extend([b.idx for b in brs])
            from_bus.extend([b.from_bus for b in brs])
            to_bus.extend([b.to_bus for b in brs])
            r.extend([b.r for b in brs])
            l.extend([b.l for b in brs]) # compute equivalent reactance 

        self.branches = pd.DataFrame({'idx': idx, 'from_bus': from_bus, 'to_bus': to_bus, 'r': r, 'l': l}).set_index('idx')

    def build_shunts_dataframe(self):
        '''It contains shunts and some of them may come from dissecting a line into branches and shunts.
                  bus_idx     g         b
        sh_idx                               
        sh_linebkdn1        1  0.05  0.066667'''

        idx, bus_idx, g, b = [], [], [], []

        shunt_types_list = self.system.shunt_types_list

        for shuntype in shunt_types_list: # iterate over each branch type
            shs = getattr(self.system, shuntype)
            idx.extend([s.idx for s in shs])
            bus_idx.extend([s.bus_idx for s in shs])
            g.extend([s.g for s in shs])
            b.extend([s.b for s in shs])

        self.shunts = pd.DataFrame({'idx': idx, 'bus_idx': bus_idx, 'g': g, 'b': b}).set_index('idx')

    def run_acopf(self):
        '''
        Computes a power flow solution for a given system minimizing load shedding and other operation penalities.
        To run this ACOPF, one generator and one bus is at least required.
        '''

        print("(*) Run power flow model:")
        # Inputs:
        generators = self.generators.copy()
        buses = self.buses.copy()
        shunts = self.shunts.copy() if not self.shunts.empty else None
        branches = self.branches.copy() if not self.branches.empty else None

        # Create GAMSPy container.
        m = gsp.Container()

        # Set up constants
        pshed_cost = self.acopf_settings['shedding_cost'] # Cost of active power shedding at any bus
        qshed_cost = self.acopf_settings['shedding_cost'] # Cost of reactive power shedding at any bus
        power_flow_equation_type = self.acopf_settings['formulation_type'] # It determines the type of formulation of the power flow equations

        # Create set of buses
        n = gsp.Set(m, name='bus_idx', records=buses.index)
        k = gsp.Alias(m, alias_with=n) # Necessary to iterate over buses twice in the power flow formulation.

        # Build admittance matrix
        if shunts is not None or branches is not None:
            Y = graph_matrices.build_admittance_matrix(len(buses), branch_data=branches, shunt_data=shunts)

            # Create admittance magnitude [p.u.] matrix. This is used for polar form formulation of power flow.
            Ymag = gsp.Parameter(m, domain=[n,k], records=np.abs(Y))

            # Create admittance angle [rad] matrix. This is used for polar form formulation of power flow.
            Yphase = gsp.Parameter(m, domain=[n,k], records=np.angle(Y))

            # Create conductance matrix [p.u.]. This is used for cartesian formulation of power flow.
            G = gsp.Parameter(m, domain=[n,k], records=Y.real)

            # Create susceptance matrix [p.u.]. This is used for cartesian formulation of power flow.
            B = gsp.Parameter(m, domain=[n,k], records=Y.imag)

        # Create set of generators
        g = gsp.Set(m, name = 'gen_idx', records=generators.index)

        # Create link sets: (bus, gen). It is necessary to create bus power generation.
        bus_gen_connections = generators.reset_index()[['bus_idx', 'idx']].apply(tuple, axis=1)
        bus_gen = gsp.Set(m, domain=[n, g], records=list(bus_gen_connections))

        # Create active and reactive load [p.u.] parameters per bus.
        p_load = gsp.Parameter(m, domain=[n], records=buses['p_load'])
        q_load = gsp.Parameter(m, domain=[n], records=buses['q_load'])

        # Create limits [p.u.] for power generation.
        pg_max = gsp.Parameter(m, domain=[g], records=generators['p_max'])
        pg_min = gsp.Parameter(m, domain=[g], records=generators['p_min'])

        qg_max = gsp.Parameter(m, domain=[g], records=generators['q_max'])
        qg_min = gsp.Parameter(m, domain=[g], records=generators['q_min'])

        # Create the decision variable and set limits for active and reactive power generation [p.u.].
        pg = gsp.Variable(m, domain=[g])
        pg.lo[g] = pg_min[g]
        pg.up[g] = pg_max[g]

        qg = gsp.Variable(m, domain=[g])
        qg.lo[g] = qg_min[g]
        qg.up[g] = qg_max[g]

        # Create decision variable that represents voltage magnitude [p.u] and voltage phase [rad].
        vmag = gsp.Variable(m, domain=[n])
        vphase = gsp.Variable(m, domain=[n])

        # Create and set limits for the voltage magnitude and voltage phase across buses.
        vmag_max = gsp.Parameter(m, domain=[n], records=buses['v_max'])
        vmag_min = gsp.Parameter(m, domain=[n], records=buses['v_min'])

        vmag.lo[n] = vmag_min[n]
        vmag.up[n] = vmag_max[n]

        vphase.lo[n] = -np.pi/2
        vphase.up[n] = +np.pi/2

        vphase.fx["1"] = 0  # Fix voltage phase of first bus to zero. 

        # Create variables that represent active and reactive power shedding [p.u.] at every bus.
        pshed = gsp.Variable(m, domain=[n], type='Positive')
        qshed = gsp.Variable(m, domain=[n], type='Positive')

        # Create variable for active power generation at every bus.
        pg_bus = gsp.Variable(m, domain=[n])

        # Define equation for bus active power generation .
        pg_bus_def = gsp.Equation(m, domain=[n])
        pg_bus_def[n]= pg_bus[n] == gsp.Sum(g.where[bus_gen[n,g]], pg[g])

        # Create variable for reactive power generation at every bus.
        qg_bus = gsp.Variable(m, domain=[n])

        # Define equation for bus reactive power generation 
        qg_bus_def = gsp.Equation(m, domain=[n])
        qg_bus_def[n]= qg_bus[n] == gsp.Sum(g.where[bus_gen[n,g]], qg[g])

        # Create variable that represents active and reactive power flow [p.u] flowing out of any bus.
        pflow = gsp.Variable(m, domain=[n])
        qflow = gsp.Variable(m,domain=[n])

        if shunts is not None or branches is not None:

            # Define equation that formulates the active power flow flowing out of any bus.
            pflow_def = gsp.Equation(m, domain=[n])
            qflow_def = gsp.Equation(m, domain=[n])

            match power_flow_equation_type:
                case 'polar_form':

                    pflow_def[n]= pflow[n] == gsp.Sum(k, vmag[n]*vmag[k]*Ymag[n,k]*gsp.math.cos(Yphase[n,k] - vphase[n] + vphase[k]))

                    qflow_def[n] = qflow[n] == -gsp.Sum(k, vmag[n]*vmag[k]*Ymag[n,k]*gsp.math.sin(Yphase[n,k] - vphase[n] + vphase[k]))

                case 'cartesian_form':
                    pflow_def[n]= pflow[n] == vmag[n]*gsp.Sum(k, vmag[k]*(G[n,k]*gsp.math.cos(vphase[n] - vphase[k]) 
                                                             + B[n,k]*gsp.math.sin(vphase[n] - vphase[k])))

                    qflow_def[n] = qflow[n] == vmag[n]*gsp.Sum(k, vmag[k]*(G[n,k]*gsp.math.sin(vphase[n] - vphase[k])) 
                                                             - B[n,k]*gsp.math.cos(vphase[n] - vphase[k]) )

        else: 
            pflow[n].fx = 0
            qflow[n].fx = 0

        # Create active and reactive power balance equation at any bus. The constant 100 may improve numerical issues.
        pbalance = gsp.Equation(m, domain=[n])
        pbalance[n] = 100*(pg_bus[n] + pshed[n] - p_load[n]) == 100*pflow[n]

        qbalance = gsp.Equation(m, domain=[n])
        qbalance[n] = 100*(qg_bus[n] + qshed[n] - q_load[n]) == 100*qflow[n]

        # Definition of objective function
        f = gsp.Sum(n, pshed_cost*pshed[n] + qshed_cost*qshed[n])

        # Create optimization model.
        opt = gsp.Model(m, 
                        name='acopf_model', 
                        problem='NLP', 
                        equations=m.getEquations(), 
                        sense=gsp.Sense.MIN, 
                        objective=f)

        # Solve optimization model. 
        self.solver_summary = opt.solve(    solver=self.acopf_settings['solver'], 
                                            options=gsp.Options(equation_listing_limit=100))
    
        # Simplify dataframes, removing marginal, scale, and other columns generated by gamspy.
        df_list = [vmag, vphase, pg, qg, pg_bus, qg_bus]
        mod_df_list = []
        for df in df_list:
            df1 = df.records
            df1.iloc[:, 0] = df1.iloc[:, 0].astype(str)
            df1.set_index(df1.columns[0], inplace=True)
            df1.drop(['marginal', 'scale', 'lower', 'upper'], axis=1, inplace=True)
            mod_df_list.append(df1)
        
        vmag, vphase, pg, qg, pg_bus, qg_bus = mod_df_list[0:6]

        # The phase is converted from radians to degrees. All components will get phase in degrees as input data.
        vphase['level'] = vphase['level']*180/np.pi

        # Update bus dataframe with opf solution
        buses = buses.join(vmag).rename(columns={'level': 'vmag'})
        buses = buses.join(vphase).rename(columns={'level': 'vphase'})
        buses = buses.join(pg_bus).rename(columns={'level': 'pgen'})
        buses = buses.join(qg_bus).rename(columns={'level': 'qgen'})

        self.buses = buses.copy()

        # Update generator dataframe with opf solution
        generators = generators.join(pg).rename(columns={'level': 'p'})
        generators = generators.join(qg).rename(columns={'level': 'q'})
        generators = generators.merge(vmag.rename(columns={'level': 'bus_vmag'}), 
                                      left_on = 'bus_idx', right_index=True)
        generators = generators.merge(vphase.rename(columns={'level': 'bus_vphase'}), 
                                      left_on = 'bus_idx', right_index=True)

        self.generators = generators.copy()

        # Update branch dataframe with opf solution
        if branches is not None:
            branches = branches.merge(vmag, 
                                      left_on='from_bus', 
                                      right_index=True).rename(columns={'level':'from_bus_vmag'})
            branches = branches.merge(vmag, 
                                      left_on='to_bus', 
                                      right_index=True).rename(columns={'level':'to_bus_vmag'})
            branches = branches.merge(vphase, 
                                      left_on='from_bus', 
                                      right_index=True).rename(columns={'level':'from_bus_vphase'})
            branches = branches.merge(vphase, 
                                      left_on='to_bus', 
                                      right_index=True).rename(columns={'level':'to_bus_vphase'})
            branches[['p', 'plosses', 'q', 'qlosses']] = branches.apply(calc_power_flow_in_branch, 
                                                                        axis=1,
                                                                        result_type='expand')
            self.branches = branches

        # Update shunt dataframe with opf solution
        if shunts is not None:
            shunts = shunts.merge(vmag, left_on='bus_idx', right_index=True).rename(columns={'level': 'bus_vmag'})
            shunts = shunts.merge(vphase, left_on='bus_idx', right_index=True).rename(columns={'level': 'bus_vphase'})
            shunts[['p', 'q']] = shunts.apply(calc_power_flow_in_shunt, axis=1, result_type='expand')
            self.shunts = shunts

        # Print results to terminal
        self.print_acopf_results()

        # Print results in output folder
        self.create_output_csv_files()

        # Create named tuple so that we can access the results via attributes
        output = namedtuple('output', ['solver_summary', 
                                       'generators', 
                                       'buses', 
                                       'branches', 
                                       'shunts'])
        
        return output(solver_summary = self.solver_summary,
                      generators = self.generators,
                      buses = self.buses,
                      shunts = self.shunts,
                      branches = self.branches)

    def print_acopf_results(self):

        match self.acopf_settings['print']:
            case 'silent':
                pass
            case 'full':
                print_settings = self.print_settings
                
                print('\n')
                print("| Summary of AC power flow results")
                # Print a portion of the solver dataframe generated by gamspy after solving the model
                solver_summary = self.solver_summary[['Solver Status', 'Model Status', 'Objective', 'Solver', 'Solver Time']]
                print(solver_summary.to_markdown(**print_settings))
                print('\n')

                print('| Bus')
                df = self.buses.copy()
                df = df[['vmag', 'vphase', 'pgen', 'qgen', 'p_load', 'q_load']]
                df.rename(columns={'vmag': 'Mag. [p.u.]', 
                                   'vphase': 'Phase [deg]', 
                                   'pgen': 'Pgen [p.u.]', 
                                   'qgen': 'Qgen [p.u.]',
                                   'p_load': 'Pload [p.u.]',
                                   'q_load' : 'Qload [p.u.]'}, inplace=True)
                print(df.to_markdown(**print_settings))
                print('\n')

                print('| Generators')
                df = self.generators.copy()
                df = df[['bus_idx', 'p', 'q']]
                df.rename(columns={'bus_idx': 'Bus', 'p': 'P [p.u]', 'q': 'Q [p.u]'},
                          inplace=True)
                print(df.to_markdown(**print_settings))
                print('\n')

                print('| Branches')
                if not self.branches.empty:
                    df = self.branches.copy()
                    df = df[['from_bus', 'to_bus', 'p', 'plosses', 'qlosses']]
                    df.rename(columns={'from_bus': 'From bus',
                                       'to_bus': 'To bus',
                                       'p': 'P [p.u.]',
                                       'plosses': 'Plosses [p.u.]',
                                       'qlosses': 'Qlosses [p.u.]'},inplace=True)
                    print(df.to_markdown(**print_settings))
                    print('\n')

                print('| Shunts')
                if not self.shunts.empty:
                    df = self.shunts.copy()
                    df = df[['bus_idx', 'p', 'q']]
                    df.rename(columns={'bus_idx': 'Bus', 'p': 'P [p.u.]', 'q': 'Q [p.u.]'},
                              inplace=True)
                    print(df.to_markdown(**print_settings))
                    print('\n')

    def create_output_csv_files(self):

        outputfolder_directory = os.path.join(os.getcwd(), 'outputs') 

        if os.path.isdir(outputfolder_directory):

            print(f'> Creation of power flow data files in {outputfolder_directory}')

            filename = 'pf_solver_summary.csv'
            filepath = os.path.join(outputfolder_directory, filename)
            self.solver_summary.to_csv(filepath)
            print(f'  - {filename} ')

            filename = 'pf_buses.csv'
            filepath = os.path.join(outputfolder_directory, filename)
            self.buses.to_csv(filepath)
            print(f'  - {filename} ')

            filename = 'pf_generators.csv'
            filepath = os.path.join(outputfolder_directory, filename)
            self.generators.to_csv(filepath)
            print(f'  - {filename} ')

            filename = 'pf_branches.csv'
            filepath = os.path.join(outputfolder_directory, filename)
            self.branches.to_csv(filepath)
            print(f'  - {filename} ')

            filename = 'pf_shunts.csv'
            filepath = os.path.join(outputfolder_directory, filename)
            self.shunts.to_csv(filepath)
            print(f'  - {filename} \n')





